\cleardoublepage
\chapternonum{摘要}

在大数据时代，二分图结构被广泛应用于表示两种不同群体之间的联系。作为二分图数据挖掘领域和图论领域中的经典问题，极大二分团枚举在理论研究和现实应用中具有重要价值，在电子商务、社交网络、基因分析以及图神经网络等领域中发挥着重要作用。然而，对于大规模二分图而言，进行极大二分团枚举是非常耗时的。具体而言，现有的极大二分团枚举方法对于包含千万极大二分团规模的二分图，需要数个小时来完成枚举。因此，本文重新思考了现有方法在剪枝能力、数据结构和并行实现等三个方面的局限性，并提出了三种独立的高性能极大二分团枚举算法：

（1）针对剪枝能力受限的问题，提出激进的极大二分团枚举算法AMBEA。该算法包括激进的集合枚举树和激进的顶点合并剪枝方法两个核心技术点。目前主流的枚举方法基于集合枚举树实现，在枚举过程中会产生大量包含非极大二分团的无效枚举节点，从而影响计算性能。激进的集合枚举树激进地将每个枚举节点的二分团扩展为极大二分团，并利用低成本的节点检查方法消除大量无效的枚举节点；激进的顶点合并剪枝方法在枚举节点生成的同时，主动合并具有相同局部邻居的顶点，提升剪枝效率。实验表明，AMBEA对无效节点的剪枝能力提升达到了9.0倍，并实现了高达5.3倍的性能提升。

（2）针对静态数据结构导致的低效性问题，提出自适应的极大二分团枚举算法AdaMBE。该算法包括基于局部计算子图的优化方法和基于位图的动态子图方法两个核心技术点。基于局部计算子图的优化方法通过动态缓存枚举过程中的计算子图，优化算法的枚举过程；基于位图的动态子图方法在枚举过程中动态生成位图，通过位运算加速小型计算子图中的集合运算。实验表明，AdaMBE实现高达49.7倍的性能提升，并且能够应用于包含超过190亿个极大二分团的数据集。

（3）针对并行扩展性受限于CPU核心数量的问题，提出基于GPU的极大二分团枚举算法GMBE。该算法包括基于枚举节点重用的迭代方法、局部邻居数量感知的剪枝方法以及负载感知的任务调度方法等三个核心技术点。基于枚举节点重用的迭代方法通过重用根节点的内存，避免为新枚举节点动态分配内存，降低了内存开销；局部邻居数量感知的剪枝方法通过批量比较顶点局部邻居的方式，在剪枝的同时最小化线程分歧问题；负载感知的任务调度方法通过对运行时的大任务根据枚举节点信息进行进一步拆分，实现了细粒度的负载均衡。实验表明，GMBE实现高达70.6倍的性能提升。

综上所述，本文提出的三种算法对极大二分团枚举问题的性能提升方式进行了全面探索，将枚举介质扩展至GPU，并且在包含百亿极大二分团规模的二分图上实现极大二分团枚举。所述三种枚举方法的结合将成为未来的研究方向。

% 在当今信息技术飞速发展的背景下，大规模数据的生成和积累已成常态。为了充分挖掘和利用数据中的有效关联信息，二分图结构被广泛应用于表征不同群体之间的联系，例如电子商务中用户与商品的购买关系。极大二分团作为二分图中的一类稠密子图，代表着数据集中那些紧密连接的群体，例如电子商务中同一组商品被一群用户批量购买的情况。通过识别并枚举二分图中的极大二分团，有助于揭示二分图中的规律或共同特征，例如电子商务中的刷单行为，进而深入探究群体行为的内部脉络和联系。

% 然而，现有的极大二分团枚举方法在处理大规模二分图时性能较低，主要面临三个共同问题：在搜索空间方面，由于问题的搜索空间庞大，现有的剪枝方法效果有限；在数据结构层面，由于问题计算的不规则性，静态数据结构无法高效处理；在并行扩展层面，由于问题负载不均衡，现有方法的并行扩展能力受限。针对这三个问题，本文提出了三种独立的高性能极大二分团枚举算法，以加速极大二分团枚举过程。

% 首先，现有方法通常基于集合枚举树的枚举结构实现，然而这些方法在搜索过程中会生成大量包含非极大二分团的无效枚举树节点，导致高昂的计算开销。因此，我们提出了激进的极大二分团枚举算法（AMBEA），包括激进的集合枚举树（ASE）和激进的顶点合并剪枝方法（AMP）两个核心技术点，有效减少了搜索空间和运行时间。具体来说，激进的集合枚举树突破了枚举树结构的限制，始终使用全部顶点将枚举过程中产生的每个二分团扩展为极大二分团，从而减少了产生非极大二分团分支的数量；激进的顶点合并剪枝方法通过改变节点生成过程，主动合并具有相同局部邻居的顶点，提升了剪枝效率。实验证明，相较现有方法，AMBEA能压缩2.37至8.98倍的搜索空间，缩短1.15至5.32倍的运行时间。

% 其次，现有方法通常采用内存使用最少的邻接表方式存储二分图，导致集合运算效率低下。因此，我们提出了自适应的极大二分团枚举算法（AdaMBE），包括基于局部计算子图的优化方法（LCG）和基于位图的动态子图方法（BDS）两个核心技术点。基于局部计算子图的优化方法通过动态缓存枚举过程中的计算子图，优化算法的枚举过程，从而减少无效的顶点访问、集合运算和枚举节点；基于位图的动态子图方法在枚举过程中动态生成位图，通过位运算加速小型计算子图中的集合运算，充分结合了邻接表与位图的优势。实验证明，相较现有方法，AdaMBE缩短了1.6至49.7倍的运行时间，并成功处理了超过190亿个极大二分团的枚举需求。

% 最后，现有方法通常在基于CPU的系统中运行，并行扩展性受限于CPU计算核心的数量。因此，我们引入了具有大量计算核心的GPU作为计算资源，提出了基于GPU的极大二分团枚举算法（GMBE），包括基于枚举节点重用的迭代方法、局部邻居数量感知的剪枝方法以及负载感知的任务调度方法等三个核心技术点。基于枚举节点重用的迭代方法通过重用根节点的内存，避免为新枚举节点动态分配内存，降低了内存开销；局部邻居数量感知的剪枝方法通过批量比较顶点局部邻居的方式，在剪枝的同时最小化线程分歧问题；负载感知的任务调度方法通过对运行时的大任务根据枚举节点信息进行进一步拆分，实现了细粒度的负载均衡。实验证明，相较现有并行算法，GMBE方法实现了70.6倍的性能提升。

\vspace{\baselineskip}

\noindent \textbf{关键词}: 二分图，极大二分团枚举，集合枚举树，位图，GPU

\cleardoublepage
\chapternonum{Abstract}

In the era of big data, bipartite graph structures are widely used to represent connections between two different groups. As a classic problem in bipartite graph data mining and graph theory, maximal biclique enumeration has significant value in theoretical research and practical applications, playing important roles in areas such as e-commerce, social networks, genetic analysis, and graph neural networks. However, for large-scale bipartite graphs, enumerating maximal bicliques is extremely time-consuming. Specifically, existing maximal biclique enumeration methods require several hours to complete the enumeration for bipartite graphs containing millions of maximal bicliques. Therefore, this paper reconsiders the limitations of existing methods in three aspects: pruning capability, data structure, and parallel implementation, and proposes three independent high-performance maximal biclique enumeration algorithms:

(1) To address the issue of limited pruning capability, the paper proposes the Aggressive Maximal Biclique Enumeration Algorithm (AMBEA). The algorithm includes two core techniques: an aggressive set enumeration tree and an aggressive merge-based pruning method. Mainstreaming enumeration methods are based on set enumeration trees, which generate a large number of invalid enumeration nodes containing non-maximal bicliques during the enumeration process, thus affecting computational performance. The aggressive set enumeration tree aggressively expands the biclique of each enumeration node into a maximal biclique and eliminates a large number of invalid enumeration nodes using a low-cost node checking method. The aggressive merge-based pruning method actively merges vertices with the same local neighbors to improve pruning efficiency. Experiments show that AMBEA achieves a 9.0x improvement in pruning capability for invalid nodes and a performance improvement of up to 5.3x.

(2) To address the inefficiency caused by static data structures, the paper proposes the Adaptive Maximal Biclique Enumeration Algorithm (AdaMBE). The algorithm includes two core techniques: optimization based on local computational subgraphs and a bitmap-based dynamic subgraph approach. The optimization based on local computational subgraphs dynamically caches the computational subgraphs during the enumeration process to optimize the enumeration process. Bitmap-based dynamic subgraph approach dynamically generates bitmaps during the enumeration process and accelerates set operations in small computational subgraphs through bitwise operations. Experiments show that AdaMBE achieves a performance improvement of up to 49.7x and successfully handles the enumeration requirements of datasets containing over 19 billion maximal bicliques.

(3) To address the limitation of parallel scalability due to the number of CPU cores, the paper proposes the GPU-based Maximal Biclique Enumeration Algorithm (GMBE). The algorithm includes three core techniques: stack-based iteration with node reuse, pruning method based on local neighborhood size, and load-aware task scheduling. The stack-based iteration with node reuse avoids dynamically allocating memory for new enumeration nodes by reusing memory from root nodes, reducing memory overhead. The pruning method based on local neighborhood size minimizes thread divergence issues by comparing a batch of local neighborhood sizes of vertices while pruning. The load-aware task scheduling further splits large tasks during runtime based on enumeration node information, achieving fine-grained load balancing. Experiments show that GMBE achieves a performance improvement of up to 70.6x.

In summary, this paper comprehensively explores ways to improve the performance of maximal biclique enumeration problems, extends enumeration to GPUs, and successfully enumerates all maximal bicliques on bipartite graphs containing billions of maximal bicliques. The combination of the three enumeration methods will be a future research direction.








% In the context of rapid development in information technology, the generation and accumulation of large-scale data have become commonplace. In order to fully explore and utilize the valuable correlation information within the data, bipartite graph structures are widely used to represent connections between different groups, such as the purchasing relationships between users and products in e-commerce. Maximal bicliques, as a type of dense subgraph in bipartite graphs, represent tightly connected groups in a dataset, such as cases where a group of users collectively purchase a set of products in e-commerce. Identifying and enumerating maximal bicliques in bipartite graphs help reveal patterns or common characteristics within the graph, such as fraudulent behavior in e-commerce, and further delve into the internal dynamics and connections within group behavior.

% However, existing methods for enumerating maximal bicliques suffer from low performance when dealing with large-scale bipartite graphs, mainly facing three common problems. Firstly, in terms of the search space, existing pruning methods have limited effectiveness due to the vast search space of the problem. Secondly, at the data structure level, the irregularity of the problem computation makes it inefficient to handle with a static data structure. Lastly, in terms of parallel expansion, the uneven workload of the problem restricts the parallel scalability of existing methods. To address these three issues, this article proposes three independent high-performance algorithms for enumerating maximal bicliques, aiming to improve the performance of the task.

% Firstly, existing methods usually rely on the enumeration structure of set enumeration trees. However, these methods generate a large number of invalid enumeration tree nodes that contain non-maximal bicliques during the search process, resulting in high computational costs. Therefore, we propose an Aggressive Maximal Bicliques Enumeration Algorithm (AMBEA), which consists of two core techniques: Aggressive Set Enumeration (ASE) tree and Aggressive Merge-based Pruning (AMP) approach. These techniques effectively reduce the search space and runtime. Specifically, the ASE tree breaks through the limitations of the enumeration tree structure by always using all vertices to expand each biclique generated during the enumeration process into a maximal biclique, thereby reducing the number of non-maximal biclique branches generated. the AMP approach improves pruning efficiency by changing the node generation process and actively merging vertices with the same local neighbors. Experimental results demonstrate that compared to existing methods, AMBEA can compress the search space by a factor of 2.37 to 8.98 and shorten the runtime by a factor of 1.15 to 5.32.

% Secondly, existing methods typically use adjacency lists as the memory-efficient way to store bipartite graphs, resulting in inefficient set operations. 
% Therefore, we propose an adaptive algorithm for enumerating maximal bicliques (AdaMBE), which consists of two core techniques: Local Computational subGraph (LCG) approach and the Bitmap-based Dynamic Subgraph (BDS) approach. The LCG approach dynamically caches computational subgraphs during the enumeration process, optimizing the enumeration process of the algorithm, thereby reducing invalid vertex accesses, set operations, and enumeration nodes. The DBS approach dynamically generates bitmaps during the enumeration process, accelerating set operations in small computational subgraphs through bitwise operations, fully leveraging the advantages of adjacency lists and bitmaps. Experimental results demonstrate that compared to existing methods, AdaMBE reduces running time by a factor ranging from 1.6 to 49.7 and successfully handles the enumeration requirements of over 19 billion maximal bicliques.

% Finally, existing methods typically run on CPU-based systems, and their parallel scalability is limited by the number of CPU cores. Therefore, we introduce GPUs with a large number of computing cores as computational resources and propose a GPU-based Maximal Biclique Enumeration (GMBE) algorithm. It includes three core techniques: stack-based iteration with enumeration node reuse, pruning using local neighborhood size, and load-aware task scheduling. The stack-based iteration with enumeration node reuse technique avoids dynamic memory allocation for new enumeration nodes by reusing the memory of root nodes, reducing memory overhead. The pruning using local neighborhood size approach minimizes thread divergence issues while pruning by comparing the local neighbors of vertices in batches. The load-aware task scheduling achieves fine-grained load balancing by further splitting large tasks during runtime based on enumeration node information. Experimental results demonstrate that compared to existing parallel algorithms, GMBE achieves a performance improvement of 70.6 times.

\vspace{\baselineskip}

\noindent \textbf{Keywords}: Bipartite Graph, Maximal Biclique Enumeration, Set Enumeration Tree, Bitmap, GPU