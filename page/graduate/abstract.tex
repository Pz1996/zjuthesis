\cleardoublepage
\chapternonum{摘要}

在当今信息技术飞速发展的背景下，大规模数据的生成和积累已成常态。为了充分挖掘和利用数据中的有效关联信息，二分图结构被广泛应用于表征不同群体之间的联系，例如电子商务中用户与商品的购买关系。极大二分团作为二分图中的一类稠密子图，代表着数据集中那些紧密连接的群体，例如电子商务中同一组商品被一群用户批量购买的情况。通过识别并枚举二分图中的极大二分团，有助于揭示二分图中的规律或共同特征，例如电子商务中的刷单行为，进而深入探究群体行为的内部脉络和联系。

然而，现有的极大二分团枚举方法在处理大规模二分图时性能较低，主要面临三个共同问题：在搜索空间方面，由于问题的搜索空间庞大，现有的剪枝方法效果有限；在数据结构层面，由于问题计算的不规则性，单一数据结构无法高效处理；在并行扩展层面，由于问题负载不均衡，现有方法的并行扩展能力受限。针对这三个问题，本文提出了三种独立的高性能极大二分团枚举算法，以提升极大二分团枚举任务的性能。

首先，现有方法通常基于集合枚举树的枚举结构实现，然而这些方法在搜索过程中会生成大量包含非极大二分团的无效枚举树节点，导致高昂的计算开销。因此，我们提出了激进的极大二分团枚举算法（AMBEA），包括激进的集合枚举树（ASE）和激进的顶点合并剪枝方法（AMP）两个核心技术点，有效减少了搜索空间和运行时间。具体来说，激进的集合枚举树突破了枚举树结构的限制，始终使用全部顶点将枚举过程中产生的每个二分团扩展为极大二分团，从而减少了产生非极大二分团分支的数量；激进的顶点合并剪枝方法通过改变节点生成过程，主动合并具有相同局部邻居的顶点，提升了剪枝效率。实验证明，相较现有方法，AMBEA能压缩2.37至8.98倍的搜索空间，缩短1.15至5.32倍的运行时间。

其次，现有方法通常采用内存使用最少的邻接表方式存储二分图，导致集合运算效率低下。因此，我们提出了自适应的极大二分团枚举算法（AdaMBE），包括基于位图的动态子图方法（BDS）和局部邻居缓存方法（LNC）两个核心技术点，成功应对了包含超过190亿个极大二分团的枚举需求。基于位图的动态子图方法在枚举过程中动态生成位图，通过位运算加速集合运算，充分结合了邻接表与位图的优势；局部邻居缓存方法通过动态保存顶点的活跃邻居，减少了冗余计算，包括对非极大二分团节点的计算、重复集合运算以及无效顶点的访问等。实验证明，相较现有方法，AdaMBE缩短了1.6至49.7倍的运行时间，并成功处理了超过190亿个极大二分团的枚举需求。

最后，现有方法通常在基于CPU的系统中运行，并行扩展性受限于CPU计算核心的数量。因此，我们引入了具有大量计算核心的GPU作为计算资源，提出了基于GPU的极大二分团枚举算法（GMBE），包括基于枚举节点重用的迭代方法、局部邻居数量感知的剪枝方法以及负载感知的任务调度方法等三个核心技术点。基于枚举节点重用的迭代方法通过重用根节点的内存，避免为新枚举节点动态分配内存，降低了内存开销；局部邻居数量感知的剪枝方法通过批量比较顶点局部邻居的方式，在剪枝的同时最小化线程分歧问题；负载感知的任务调度方法通过对运行时的大任务根据枚举节点信息进行进一步拆分，实现了细粒度的负载均衡。实验证明，相较现有并行算法，GMBE方法实现了70.6倍的性能提升。

\vspace{\baselineskip}

\noindent \textbf{关键词}: 二分图, 极大二分团枚举, 集合枚举树, 位图, GPU

\cleardoublepage
\chapternonum{Abstract}

In the context of rapid development in information technology, the generation and accumulation of large-scale data have become commonplace. In order to fully explore and utilize the valuable correlation information within the data, bipartite graph structures are widely used to represent connections between different groups, such as the purchasing relationships between users and products in e-commerce. Maximal bicliques, as a type of dense subgraph in bipartite graphs, represent tightly connected groups in a dataset, such as cases where a group of users collectively purchase a set of products in e-commerce. Identifying and enumerating maximal bicliques in bipartite graphs help reveal patterns or common characteristics within the graph, such as fraudulent behavior in e-commerce, and further delve into the internal dynamics and connections within group behavior.

However, existing methods for enumerating maximal bicliques suffer from low performance when dealing with large-scale bipartite graphs, mainly facing three common problems. Firstly, in terms of the search space, existing pruning methods have limited effectiveness due to the vast search space of the problem. Secondly, at the data structure level, the irregularity of the problem computation makes it inefficient to handle with a single data structure. Lastly, in terms of parallel expansion, the uneven workload of the problem restricts the parallel scalability of existing methods. To address these three issues, this article proposes three independent high-performance algorithms for enumerating maximal bicliques, aiming to improve the performance of the task.

Firstly, existing methods usually rely on the enumeration structure of set enumeration trees. However, these methods generate a large number of invalid enumeration tree nodes that contain non-maximal bicliques during the search process, resulting in high computational costs. Therefore, we propose an Aggressive Maximal Bicliques Enumeration Algorithm (AMBEA), which consists of two core techniques: Aggressive Set Enumeration (ASE) tree and Aggressive Merge-based Pruning (AMP) approach. These techniques effectively reduce the search space and runtime. Specifically, the ASE tree breaks through the limitations of the enumeration tree structure by always using all vertices to expand each biclique generated during the enumeration process into a maximal biclique, thereby reducing the number of non-maximal biclique branches generated. the AMP approach improves pruning efficiency by changing the node generation process and actively merging vertices with the same local neighbors. Experimental results demonstrate that compared to existing methods, AMBEA can compress the search space by a factor of 2.37 to 8.98 and shorten the runtime by a factor of 1.15 to 5.32.

Secondly, existing methods typically use adjacency lists as the memory-efficient way to store bipartite graphs, resulting in inefficient set operations. Therefore, we propose an Adaptive Maximal Biclique Enumeration (AdaMBE) algorithm, which includes two core techniques: Bitmap-based Dynamic Subgraph (BDS) and Local Neighbor Caching (LNC). These techniques successfully address the enumeration needs involving over 19 billion maximal bicliques. BDS dynamically generates bitmaps during the enumeration process and accelerates set operations through bitwise operations, fully combining the advantages of adjacency lists and bitmaps. LNC reduces redundant computations by dynamically saving the active neighbors of vertices, including computations on non-maximal biclique nodes, repeated set operations, and accessing invalid vertices. Experimental results show that compared to existing methods, AdaMBE reduces the runtime by a factor of 1.6 to 49.7 and successfully handles the enumeration needs of over 19 billion maximal bicliques.

Finally, existing methods typically run on CPU-based systems, and their parallel scalability is limited by the number of CPU cores. Therefore, we introduce GPUs with a large number of computing cores as computational resources and propose a GPU-based Maximal Biclique Enumeration (GMBE) algorithm. It includes three core techniques: stack-based iteration with enumeration node reuse, pruning using local neighborhood size, and load-aware task scheduling. The stack-based iteration with enumeration node reuse technique avoids dynamic memory allocation for new enumeration nodes by reusing the memory of root nodes, reducing memory overhead. The pruning using local neighborhood size approach minimizes thread divergence issues while pruning by comparing the local neighbors of vertices in batches. The load-aware task scheduling achieves fine-grained load balancing by further splitting large tasks during runtime based on enumeration node information. Experimental results demonstrate that compared to existing parallel algorithms, GMBE achieves a performance improvement of 70.6 times.

\vspace{\baselineskip}

\noindent \textbf{Keywords}: Bipartite Graph, Maximal Biclique Enumeration, Set Enumeration Tree, Bitmap, GPU